#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: codex-batch-panes <batch-dir> [options]

Create a tmux session with one pane per worktree directory and run a command
in each pane (default: "codex -a never -s danger-full-access begin").

Options:
  --repo URL|PATH  clone repo into <batch-dir>/.source and create worktrees
  --agents N       number of agent worktrees to create (requires --repo)
  --names LIST     comma-separated worktree names (requires --repo)
  --names-file F   newline-separated worktree names (requires --repo)
  --prefix PREFIX  worktree dir prefix for --agents (default: agent-)
  --branch REF     base branch/ref for new worktrees (default: origin HEAD)
  --branch-prefix P prefix for per-agent branches (default: agent/)
  --detach         create detached worktrees (no per-agent branches)
  --session NAME   tmux session name (default: basename of batch dir)
  --cmd CMD        command to run in each pane (overrides --safe/--danger)
  --layout LAYOUT  tmux layout (default: tiled)
  --safe           use default codex config ("codex begin")
  --danger         use full-access mode (default)
  --attach         attach after setup (default)
  --no-attach      do not attach
  --iterm2         attach using iTerm2 tmux integration (tmux -CC)
  --replace        kill existing session with the same name
  -h, --help       show this help
EOF
}

die() {
  echo "error: $*" >&2
  exit 1
}

trim() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

require_command() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    die "$cmd is not installed"
  fi
}

batch_dir=""
session_name=""
cmd_mode="danger"
cmd_override=""
layout="tiled"
attach="true"
use_iterm2="false"
replace="false"
repo=""
agent_count=""
names_csv=""
names_file=""
prefix="agent-"
base_branch=""
branch_prefix="agent/"
detach="false"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --session)
      session_name="${2:-}"
      shift 2
      ;;
    --cmd)
      cmd_override="${2:-}"
      shift 2
      ;;
    --layout)
      layout="${2:-}"
      shift 2
      ;;
    --repo)
      repo="${2:-}"
      shift 2
      ;;
    --agents)
      agent_count="${2:-}"
      shift 2
      ;;
    --names)
      names_csv="${2:-}"
      shift 2
      ;;
    --names-file)
      names_file="${2:-}"
      shift 2
      ;;
    --prefix)
      prefix="${2:-}"
      shift 2
      ;;
    --branch)
      base_branch="${2:-}"
      shift 2
      ;;
    --branch-prefix)
      branch_prefix="${2:-}"
      shift 2
      ;;
    --detach)
      detach="true"
      shift
      ;;
    --safe)
      cmd_mode="safe"
      shift
      ;;
    --danger)
      cmd_mode="danger"
      shift
      ;;
    --attach)
      attach="true"
      shift
      ;;
    --no-attach)
      attach="false"
      shift
      ;;
    --iterm2)
      use_iterm2="true"
      shift
      ;;
    --replace)
      replace="true"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      die "unknown option: $1"
      ;;
    *)
      if [[ -z "$batch_dir" ]]; then
        batch_dir="$1"
      else
        die "unexpected argument: $1"
      fi
      shift
      ;;
  esac
done

if [[ -z "$batch_dir" ]]; then
  usage
  exit 1
fi

if [[ -n "$names_csv" && -n "$names_file" ]]; then
  die "use only one of --names or --names-file"
fi

if [[ -n "$names_csv" && -n "$agent_count" ]]; then
  die "use only one of --names or --agents"
fi

if [[ -n "$names_file" && -n "$agent_count" ]]; then
  die "use only one of --names-file or --agents"
fi

if [[ -n "$agent_count" ]]; then
  if [[ ! "$agent_count" =~ ^[0-9]+$ ]] || [[ "$agent_count" -lt 1 ]]; then
    die "--agents must be a positive integer"
  fi
fi

if [[ -n "$repo" ]]; then
  mkdir -p "$batch_dir"
elif [[ ! -d "$batch_dir" ]]; then
  die "batch dir not found: $batch_dir"
fi

batch_dir="$(cd "$batch_dir" && pwd -P)"

if [[ -n "$agent_count" || -n "$names_csv" || -n "$names_file" ]]; then
  if [[ -z "$repo" ]]; then
    die "--agents/--names require --repo"
  fi
fi

require_command tmux

if [[ -n "${TMUX:-}" && "$attach" == "true" ]]; then
  die "already inside tmux; rerun with --no-attach or from a non-tmux shell"
fi

if [[ -z "$session_name" ]]; then
  session_name="$(basename "$batch_dir")"
  session_name="$(echo "$session_name" | tr -c 'A-Za-z0-9._-' '-' | sed 's/^-*//;s/-*$//')"
  [[ -z "$session_name" ]] && session_name="agents"
fi

if [[ -n "$repo" || -n "$agent_count" || -n "$names_csv" || -n "$names_file" ]]; then
  require_command git
fi

if [[ -n "$cmd_override" ]]; then
  cmd="$cmd_override"
else
  if [[ "$cmd_mode" == "safe" ]]; then
    cmd="codex begin"
  else
    cmd="codex -a never -s danger-full-access begin"
  fi
fi

names=()
if [[ -n "$names_csv" ]]; then
  IFS=',' read -r -a raw_names <<< "$names_csv"
  for name in "${raw_names[@]}"; do
    name="$(trim "$name")"
    [[ -n "$name" ]] && names+=("$name")
  done
elif [[ -n "$names_file" ]]; then
  if [[ ! -f "$names_file" ]]; then
    die "names file not found: $names_file"
  fi
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    line="$(trim "$line")"
    [[ -n "$line" ]] && names+=("$line")
  done < "$names_file"
elif [[ -n "$agent_count" ]]; then
  width="${#agent_count}"
  [[ "$width" -lt 2 ]] && width=2
  for ((i=1; i<=agent_count; i++)); do
    names+=("${prefix}$(printf "%0*d" "$width" "$i")")
  done
fi

if [[ -n "$repo" ]]; then
  source_dir="$batch_dir/.source"
  if [[ -d "$source_dir" ]]; then
    if [[ ! -d "$source_dir/.git" ]]; then
      die "source dir exists but is not a git repo: $source_dir"
    fi
    existing_origin="$(git -C "$source_dir" config --get remote.origin.url || true)"
    if [[ -n "$existing_origin" && "$existing_origin" != "$repo" ]]; then
      die "source repo origin mismatch: $existing_origin (expected $repo)"
    fi
  else
    git clone "$repo" "$source_dir"
  fi

  if [[ -z "$base_branch" ]]; then
    base_branch="$(git -C "$source_dir" symbolic-ref -q --short refs/remotes/origin/HEAD || true)"
    base_branch="${base_branch#origin/}"
  fi

  if [[ -z "$base_branch" ]]; then
    if git -C "$source_dir" show-ref --verify --quiet refs/remotes/origin/main; then
      base_branch="main"
    elif git -C "$source_dir" show-ref --verify --quiet refs/remotes/origin/master; then
      base_branch="master"
    else
      base_branch="main"
    fi
  fi

  if [[ ${#names[@]} -gt 0 ]]; then
    start_ref="origin/$base_branch"
    if ! git -C "$source_dir" rev-parse --verify "$start_ref^{commit}" >/dev/null 2>&1; then
      start_ref="$base_branch"
      if ! git -C "$source_dir" rev-parse --verify "$start_ref^{commit}" >/dev/null 2>&1; then
        die "base ref not found: $base_branch (use --branch)"
      fi
    fi

    for name in "${names[@]}"; do
      worktree_dir="$batch_dir/$name"
      if [[ -e "$worktree_dir/.git" ]]; then
        continue
      fi
      if [[ -e "$worktree_dir" ]]; then
        die "path exists but is not a worktree: $worktree_dir"
      fi
      if [[ "$detach" == "true" ]]; then
        git -C "$source_dir" worktree add --detach "$worktree_dir" "$start_ref"
      else
        branch_name="${branch_prefix}${name}"
        if git -C "$source_dir" show-ref --verify --quiet "refs/heads/$branch_name"; then
          git -C "$source_dir" worktree add "$worktree_dir" "$branch_name"
        else
          git -C "$source_dir" worktree add -b "$branch_name" "$worktree_dir" "$start_ref"
        fi
      fi
    done
  fi
fi

dirs=()
if [[ ${#names[@]} -gt 0 ]]; then
  for name in "${names[@]}"; do
    dir="$batch_dir/$name"
    [[ -e "$dir/.git" ]] || die "worktree missing: $dir"
    dirs+=("$dir")
  done
else
  for dir in "$batch_dir"/*; do
    [[ -d "$dir" ]] || continue
    [[ -e "$dir/.git" ]] || continue
    dirs+=("$dir")
  done
fi

if [[ ${#dirs[@]} -eq 0 ]]; then
  die "no worktrees found in $batch_dir"
fi

if tmux has-session -t "$session_name" 2>/dev/null; then
  if [[ "$replace" == "true" ]]; then
    tmux kill-session -t "$session_name"
  elif [[ "$attach" == "true" ]]; then
    if [[ "$use_iterm2" == "true" ]]; then
      tmux -CC attach -t "$session_name"
    else
      tmux attach -t "$session_name"
    fi
    exit 0
  else
    die "tmux session exists: $session_name (use --replace or --attach)"
  fi
fi

first_dir="${dirs[0]}"
tmux new-session -d -s "$session_name" -n "agents" -c "$first_dir"
first_pane="$(tmux display-message -p -t "$session_name:0.0" "#{pane_id}")"
tmux set -t "$session_name" -g pane-border-status top 2>/dev/null || true
tmux set -t "$session_name" -g pane-border-format "#{pane_title}" 2>/dev/null || true
first_label="$(basename "$first_dir")"
tmux select-pane -t "$first_pane" -T "$first_label" 2>/dev/null || true
tmux send-keys -t "$first_pane" -- \
  "export CODEX_PROJECT_ROOT=\"$first_dir\"; export CODEX_WORKTREE=\"$first_dir\"; export CODEX_WORKTREE_NAME=\"$first_label\"; $cmd" \
  C-m

for dir in "${dirs[@]:1}"; do
  pane_id="$(tmux split-window -t "$session_name:0" -c "$dir" -P -F "#{pane_id}")"
  pane_label="$(basename "$dir")"
  tmux select-pane -t "$pane_id" -T "$pane_label" 2>/dev/null || true
  tmux send-keys -t "$pane_id" -- \
    "export CODEX_PROJECT_ROOT=\"$dir\"; export CODEX_WORKTREE=\"$dir\"; export CODEX_WORKTREE_NAME=\"$pane_label\"; $cmd" \
    C-m
done

if ! tmux select-layout -t "$session_name:0" "$layout" 2>/dev/null; then
  echo "warning: tmux layout not applied: $layout" >&2
fi

if [[ "$attach" == "true" ]]; then
  if [[ "$use_iterm2" == "true" ]]; then
    tmux -CC attach -t "$session_name"
  else
    tmux attach -t "$session_name"
  fi
fi
